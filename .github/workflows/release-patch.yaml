name: 发布补丁
run-name: ${{ github.actor }} 正在发布补丁🚀
on:
  push:
    branches:
      - test-patch

jobs:
  Release:
    runs-on: ubuntu-latest
    name: 发布🚀
    steps:
      - name: Check out repository code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
      - name: 读取包名
        uses: SebRollen/toml-action@v1.2.0
        id: read-modpackname
        with:
          file: ${{ github.workspace }}/pack.toml
          field: 'name'
      - name: 读取版本号
        uses: SebRollen/toml-action@v1.2.0
        id: read-version
        with:
          file: ${{ github.workspace }}/pack.toml
          field: 'version'
      - name: 获取最近的tag并配置环境变量
        run: |
          # 获取当前 commit 的 hash
          current_commit=$(git rev-parse HEAD)
          # 获取当前 commit 关联的 tag
          current_commit_tags=$(git tag --points-at $current_commit)
          if [ -z "$current_commit_tags" ]; then
            # 当前 commit 没有关联 tag，直接取最新 tag
            latest_tag=$(git tag --sort=-creatordate | head -n 1)
          else
            # 当前 commit 有关联 tag，过滤掉这些 tag 后取最新 tag
            latest_tag=$(git tag --sort=-creatordate | grep -v "$current_commit_tags" | head -n 1)
          fi
          if [ -z "$latest_tag" ]; then
            echo "No suitable tag found. Exiting."
            exit 1
          fi
          echo "最近的tag是: $latest_tag"
          echo "LATEST_TAG=$latest_tag" >> $GITHUB_ENV
      - name: Prepare patch files
        run: |
          # 生成完整差异报告
          git diff --name-status ${{ env.LATEST_TAG }} HEAD > diff_report.txt
          
          # 解析差异报告
          grep -E '^D' diff_report.txt | cut -f2 > deleted_files.txt
          grep -E '^R' diff_report.txt | cut -f2 >> deleted_files.txt
          grep -E '^[A|M]' diff_report.txt | cut -f2 > added_files.txt
          grep -E '^R' diff_report.txt | cut -f3 >> added_files.txt
          grep -E '^C' diff_report.txt | cut -f3 >> added_files.txt

          # 创建补丁目录
          mkdir -p patch

          # 复制新增/修改文件
          while IFS= read -r file; do
            mkdir -p "patch/$(dirname "$file")"
            cp "$file" "patch/$file"
          done < added_files.txt

      - name: Create Linux script
        run: |
          cat << 'EOF' > deploy-linux.sh
          #!/bin/bash
          echo "正在应用补丁..."
          BASE_DIR=$(dirname "$(readlink -f "$0")")
          
          # 处理删除
          if [ -f "$BASE_DIR/deleted_files.txt" ]; then
            echo "正在处理删除/重命名文件..."
            while IFS= read -r line; do
              if [ -f "$file" ]; then
                rm -v "$file" || echo "无法删除 $file"
              fi
            done < "$BASE_DIR/deleted_files.txt"
          fi

          # 处理文件更新/新增
          while IFS= read -r file; do
            target_dir=$(dirname "$file")
            mkdir -p "$target_dir"
            mv -v "$BASE_DIR/patch/$file" "$file" || echo "无法复制 $file"
          done < "$BASE_DIR/added_files.txt"

          echo -e "\n操作完成！"
          EOF

      - name: Create Windows script
        run: |
          cat << 'EOF' > deploy-windows.bat
          @echo off
          setlocal enabledelayedexpansion
          echo 正在应用补丁...
          set "BASE_DIR=%~dp0"
          
          REM 处理文件删除
          if exist "%BASE_DIR%deleted_files.txt" (
            echo 正在清理已删除文件...
            for /f "delims=" %%f in (%BASE_DIR%deleted_files.txt) do (
              set "file=%%f"
              if exist "!file!" (
                del /f /q "!file!" >nul && echo 已删除: !file!
              )
            )
          )

          REM 处理文件更新/新增
          for /f "delims=" %%f in (%BASE_DIR%added_files.txt) do (
            set "file=%%f"
            set "target_dir=!file:\=/!"
            for %%d in ("!target_dir!") do set "target_dir=%%~pd"
            mkdir "!target_dir!" >nul 2>&1
            if exist "%BASE_DIR%patch\!file!" (
              move /y "%BASE_DIR%patch\!file!" "!file!" >nul && echo 已复制: !file!
            ) else (
              echo 文件不存在: !file!
            )
          )
          
          echo 操作完成！
          EOF

      - name: Archive artifacts
        run: |
          zip -r patch.zip \
            added_files.txt \
            deleted_files.txt \
            deploy-linux.sh \
            deploy-windows.bat \
            patch/

      - name: 上传补丁
        uses: actions/upload-artifact@v4
        with:
          name: "[Patch]-${{ env.LATEST_TAG }}-to-${{ steps.read-version.outputs.value }}"
          path: patch
      - run: echo "🍏 This job's status is ${{ job.status }}."
