name: 发布客户端补丁
run-name: ${{ github.actor }} 正在发布客户端补丁🚀
on:
  push:
    branches:
      - test-release
      - release

jobs:
  Release:
    runs-on: ubuntu-latest
    name: 发布🚀
    steps:
      - name: Check out repository code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true
      - name: 读取包名
        uses: SebRollen/toml-action@v1.2.0
        id: read-modpackname
        with:
          file: ${{ github.workspace }}/pack.toml
          field: 'name'
      - name: 读取版本号
        uses: SebRollen/toml-action@v1.2.0
        id: read-version
        with:
          file: ${{ github.workspace }}/pack.toml
          field: 'version'
      - name: 生成整合包nightly构建后缀
        id: set_version_prefix
        run: |
          echo ${{ steps.read-modpackname.outputs.value }}
          echo ${{ steps.read-version.outputs.value }}
          if [[ $GITHUB_REF == refs/heads/test-release ]]; then
            VERSION_SUFFIX=$(date +%m%d%H%M)
            echo "VERSION_SUFFIX=-$VERSION_SUFFIX" >> $GITHUB_OUTPUT
          else
            echo "VERSION_SUFFIX=" >> $GITHUB_OUTPUT
          fi
      - name: 获取最近的tag并配置环境变量
        run: |
          latest_tag=$(git describe --tags --abbrev=0)
          echo "最近的tag是: $latest_tag"
          echo "LATEST_TAG=$latest_tag" >> $GITHUB_ENV
      - name: 根据tag生成补丁
        run: |
          temp_dir=$(mktemp -d)
          # 创建合并记录文件
          mods_changes="$temp_dir/mods_changes.txt"
          touch "$mods_changes"

          # 获取所有有变化的文件及变化类型
          git diff --name-status ${{ env.LATEST_TAG }} HEAD | while IFS=$'\t' read -r status file; do
            echo "file: $file"
            echo "status: $status"
            if [[ $file == mods/* ]]; then
              case $status in
                A)
                  # A 表示文件被添加
                  echo "Added: $file" >> "$mods_changes"
                  ;;
                D)
                  # D 表示文件被删除
                  echo "Deleted: $file" >> "$mods_changes"
                  ;;
                R*)
                  # R 开头表示文件被更名，这里获取新文件名
                  new_file=$(echo $file | cut -d$'\t' -f2)
                  echo "Renamed: $file -> $new_file" >> "$mods_changes"
                  ;;
              esac
            else
              case $status in
                A|M)
                  if [ -e "$file" ]; then                  
                    mkdir -p "$temp_dir/$(dirname $file)"
                    cp -rL "$file" "$temp_dir/$file"
                  fi
                  ;;
                R*)
                  new_file=$(echo "$file" | cut -d$'\t' -f3)
                  if [ -e "$new_file" ]; then
                    mkdir -p "$temp_dir/$(dirname $new_file)"
                    cp -rL "$new_file" "$temp_dir/$new_file"
                  fi
                  ;;
                D)
                  echo "文件 $file 已删除，跳过复制。"
                  ;;
              esac
            fi
          done

          echo "PATCH_DIR=$temp_dir" >> $GITHUB_ENV
      - name: 从生成的补丁临时目录里删除打包会忽略的文件
        run: |
            mapfile -t names < ${{ github.workspace }}/.packwizignore
            names+=("pack.toml")
            for filename in "${names[@]}"; do
              echo "Deleting files $filename"
              find ${{ env.PATCH_DIR }} -name "${filename}" -exec rm {} +
            done
      - name: 上传补丁
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.LATEST_TAG }}-to-${{ steps.read-version.outputs.value }}${{ steps.set_version_prefix.outputs.VERSION_SUFFIX }}-patch
          path: ${{ env.PATCH_DIR }}
      - run: echo "🍏 This job's status is ${{ job.status }}."
